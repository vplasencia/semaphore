"use strict";(self.webpackChunk_semaphore_docs=self.webpackChunk_semaphore_docs||[]).push([[521],{3905:function(e,t,r){r.d(t,{Zo:function(){return c},kt:function(){return k}});var n=r(7294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var s=n.createContext({}),p=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},c=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(r),k=i,u=d["".concat(s,".").concat(k)]||d[k]||m[k]||a;return r?n.createElement(u,o(o({ref:t},c),{},{components:r})):n.createElement(u,o({ref:t},c))}));function k(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var p=2;p<a;p++)o[p]=r[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},5414:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return c},default:function(){return d}});var n=r(3117),i=r(102),a=(r(7294),r(3905)),o=["components"],l={sidebar_position:3},s="ZK-kit libraries",p={unversionedId:"technical-reference/zk-kit",id:"version-V2/technical-reference/zk-kit",title:"ZK-kit libraries",description:"When using Semaphore each user will need to create their own identity, which will then be added to a group. @zk-kit/identity allows users to create and manage their identities, while @zk-kit/protocols allows users to create Semaphore proofs to prove their group membership and signal their endorsement of an arbitrary string anonymously.",source:"@site/versioned_docs/version-V2/technical-reference/zk-kit.md",sourceDirName:"technical-reference",slug:"/technical-reference/zk-kit",permalink:"/docs/technical-reference/zk-kit",editUrl:"https://github.com/appliedzkp/semaphore/edit/main/versioned_docs/version-V2/technical-reference/zk-kit.md",tags:[],version:"V2",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"version-V2/mySidebar",previous:{title:"Contracts",permalink:"/docs/technical-reference/contracts"},next:{title:"Resources",permalink:"/docs/resources"}},c=[{value:"@zk-kit/identity",id:"zk-kitidentity",children:[],level:2},{value:"@zk-kit/protocols",id:"zk-kitprotocols",children:[],level:2}],m={toc:c};function d(e){var t=e.components,r=(0,i.Z)(e,o);return(0,a.kt)("wrapper",(0,n.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"zk-kit-libraries"},"ZK-kit libraries"),(0,a.kt)("p",null,"When using Semaphore each user will need to create their own identity, which will then be added to a group. ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/appliedzkp/zk-kit/tree/main/packages/identity"},(0,a.kt)("inlineCode",{parentName:"a"},"@zk-kit/identity"))," allows users to create and manage their identities, while ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/appliedzkp/zk-kit/tree/main/packages/protocols"},(0,a.kt)("inlineCode",{parentName:"a"},"@zk-kit/protocols"))," allows users to create Semaphore proofs to prove their group membership and signal their endorsement of an arbitrary string anonymously."),(0,a.kt)("p",null,"If you need to see the interface of these libraries go to ",(0,a.kt)("a",{parentName:"p",href:"http://zkkit.appliedzkp.org"},"http://zkkit.appliedzkp.org"),"."),(0,a.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},(0,a.kt)("a",{parentName:"p",href:"https://github.com/appliedzkp/zk-kit"},"ZK-kit")," is a set of reusable JavaScript libraries for zero-knowledge technologies. It also contains other useful libraries, such as the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/appliedzkp/zk-kit/tree/main/packages/incremental-merkle-tree.sol"},"Solidity")," and ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/appliedzkp/zk-kit/tree/main/packages/incremental-merkle-tree"},"JavaScript")," implementations of the incremental Merkle tree."))),(0,a.kt)("h2",{id:"zk-kitidentity"},"@zk-kit/identity"),(0,a.kt)("p",null,"The Semaphore identity consists primarily of two values: ",(0,a.kt)("inlineCode",{parentName:"p"},"trapdoor")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"nullifier"),". The Poseidon hash of these two values is the ",(0,a.kt)("inlineCode",{parentName:"p"},"secret"),", whose hash in turn is the ",(0,a.kt)("inlineCode",{parentName:"p"},"identity commitment"),", which is used as leaf of the Merkle tree later."),(0,a.kt)("p",null,"This library therefore contains a ",(0,a.kt)("inlineCode",{parentName:"p"},"ZKIdentity")," class that can generate these values with 3 different ",(0,a.kt)("a",{parentName:"p",href:"http://zkkit.appliedzkp.org/identity/enums/Strategy.html"},"strategies"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Strategy.RANDOM"),": this is the default option and it generates the values randomly,"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Strategy.MESSAGE"),": it allows values to be generated deterministically from a message using SHA-256,"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Strategy.SERIALIZE"),": it allows you to retrieve values from a previously serialized identity.")),(0,a.kt)("h2",{id:"zk-kitprotocols"},"@zk-kit/protocols"),(0,a.kt)("p",null,"The Semaphore proof contains public and private parameters. This library contains some utility functions to simplify the generation of these parameters. It allows, in particular, to generate a Merkle proof, the nullifier hash, the witness and a Solidity-compatible zero-knowledge proof."),(0,a.kt)("p",null,"Semaphore protocol functions are located in the ",(0,a.kt)("inlineCode",{parentName:"p"},"Semaphore")," class as static methods."),(0,a.kt)("p",null,"If you need to use a library to manage offchain Merkle trees you can also use ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/appliedzkp/zk-kit/tree/main/packages/incremental-merkle-tree"},(0,a.kt)("inlineCode",{parentName:"a"},"@zk-kit/incremental-merkle-tree")),"."))}d.isMDXComponent=!0}}]);